var CONFIG = require ('./config'),
    fs = require('fs'),
    redis = require("redis"),
    client = redis.createClient(),
    xml2js = require('xml2js'),
    parser = new xml2js.Parser(),
    child_process = require('child_process'),
    nodemailer = require('nodemailer'),
    Slack = require('node-slack');
    slack = new Slack('https://hooks.slack.com/services/' + CONFIG.SLACK_TOKEN);
    verbose = false,
    alertLog = "",
    callBackCounterToExit = 0,
    transporter = nodemailer.createTransport({
    	service: CONFIG.EMAIL_PROVIDER,
    	auth: {
    		user: CONFIG.EMAIL_USER,
    		pass: CONFIG.EMAIL_PASSWORD
    	}
    });

client.on("error", function (err) {
	console.log("Error " + err);
});

// http://stackoverflow.com/questions/1144783/replacing-all-occurrences-of-a-string-in-javascript on 20150531 @ 17:05 EST
function replaceAll(find, replace, str) {
	return str.replace(new RegExp(find, 'g'), replace);
}

function sendAlerts (alertLog) {
	for (emaillistIndex = 0; emaillistIndex < emaillist.length; emaillistIndex++) {
		// setup e-mail data with unicode symbols
		var mailOptions = {
			from: 'CVE Watch âœ” <security@alert.com>', // sender address
			to: emaillist[emaillistIndex], // list of receivers
			subject: 'New vulnerabilities found', // Subject line
			text: alertLog, // plaintext body
			html: alertLog // html body
		};

		if (alertLog != "") {
			// send mail with defined transport object
			transporter.sendMail(mailOptions, function(error, info){
				if (error){
					console.log(error);
				} else {
					if (verbose) console.log('Message sent: ' + info.response);
				}
			});

			slack.send({
				text: replaceAll ("<br />", String.fromCharCode(13) + String.fromCharCode(10), alertLog),
				channel: CONFIG.SLACK_CHANNEL,
				username: 'CVE Watch'
			}, function (error) {
				if (error != null && error.message != null) {
					console.log ("Slack: " + error.message);
				}

				// terminate the program
				console.log ("Done");
				process.exit(1);
			});
		} else {
			slack.send({
				text: "No new vulnerabilities detected",
				channel: CONFIG.SLACK_CHANNEL,
				username: 'CVE Watch'
			}, function (error) {
				if (error != null && error.message != null) {
					console.log ("Slack: " + error.message);
				}

				// terminate the program
				console.log ("Done");
				process.exit(1);
			});
		}
	}
}

function addVulerability (cve, note) {
	callBackCounterToExit++;
	client.get (cve, function (err, reply) {
		if (reply == null) {

			if (verbose) console.log ("New vulnerability " + cve);
			if (verbose) console.log ("adding to redis");
			client.set (cve, note);

			for (var currentWatchListItemIndex = 0; currentWatchListItemIndex < watchlist.length; currentWatchListItemIndex++) {
				if (note.toLowerCase().indexOf(watchlist[currentWatchListItemIndex].toLowerCase()) > -1) {
					if (verbose) console.log (cve + "\\n" + note);

					alertLog += cve + "<br />" + note + "<br /><br />";
				}
			}
		}

		if (--callBackCounterToExit == 0) {
			sendAlerts (alertLog);
		}
	});
}

function updateCVE() {
	child_process.execFile ("wget", ["http://cve.mitre.org/data/downloads/allitems-cvrf-year-2015.xml", "-O", "allitems-cvrf-year-2015.xml"], function (err, out, code) {
		fs.readFile('allitems-cvrf-year-2015.xml', function(err, data) {
			parser.parseString(data, function (err, result) {
				var numberOfVulerabilities = result.cvrfdoc.Vulnerability.length;

				for (var currentVulerabilityIndex = 0; currentVulerabilityIndex < numberOfVulerabilities; currentVulerabilityIndex++) {
					var currentVulerability = result.cvrfdoc.Vulnerability[currentVulerabilityIndex];

					addVulerability (
						currentVulerability.CVE,
						currentVulerability.Notes[0].Note[0]._
					);
				}
			});
		});
	});
}

client.get ('watchlist', function (watchlistError, watchlistRedisReply) {
	if (watchlistRedisReply != null) {
		watchlist = JSON.parse(watchlistRedisReply.toString());

		client.get ('emaillist', function (emaillistRedisError, emaillistRedisReply) {
			if (emaillistRedisReply != null) {
				emaillist = JSON.parse(emaillistRedisReply.toString());

				updateCVE ();
			} else {
				console.log ("add an item to the emaillist");
			}
		});
	} else {
		console.log ("add an item to the watchlist");
	}
});